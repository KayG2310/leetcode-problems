class DisjointSet {
public:
    vector<int> parent, size;

    DisjointSet(int n) {
        parent.resize(n);
        size.resize(n, 1);
        for(int i = 0; i < n; ++i) parent[i] = i;
    }

    int find(int u) {
        if (parent[u] == u) return u;
        return parent[u] = find(parent[u]);
    }

    void unionn(int u, int v) {
        int pu = find(u);
        int pv = find(v);
        if (pu == pv) return;
        if (size[pu] >= size[pv]) {
            parent[pv] = pu;
            size[pu] += size[pv];
        } else {
            parent[pu] = pv;
            size[pv] += size[pu];
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DisjointSet ds(n);

        // 1. Build DSU components
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < n; ++j) {
                if (graph[i][j] && i != j) {
                    ds.unionn(i, j);
                }
            }
        }

        // 2. Count infected nodes in each component
        unordered_map<int, int> infectedCount;
        for (int node : initial) {
            int leader = ds.find(node);
            infectedCount[leader]++;
        }
        sort(initial.begin(), initial.end()); 
        int result = initial[0];
        int maxSize = -1;
        for (int node : initial) {
            int leader = ds.find(node);
            if (infectedCount[leader] == 1) {
                if (ds.size[leader] > maxSize) {
                    maxSize = ds.size[leader];
                    result = node;
                }
            }
        }
        return result;
    }
};
